//NOTE: Be sure this file is loaded before other resources that utilize WAKLIBWAKLIB = {};//*** Legend//WAKLIB.utils.datasourceToObject(datasource)//WAKLIB.utils.indexOf()//WAKLIB.events.various()//WAKLIB.utils.generateFullName()//IDEAS: layout engineWAKLIB.utils = {};//*** datasourceToObject - converts a local object datasource to a pure object for use as a parameterWAKLIB.utils.datasourceToObject = function(datasource){	//parse the local object datasource into a simple object with name/value pairs	var returnObject = {};	var attributes = datasource.getDataClass(); //gets an array of all attributes in the datasource object	for (i in attributes) {	    if (attributes.hasOwnProperty(i)) {	        returnObject[i] = datasource[i]; //copies the value from the datasource to the new object	    }	}	return returnObject; //returns the simplified object}WAKLIB.utils.isEmpty = function(value){	if(value == null || value == undefined || value == '' || value == 0 || value == {} || value == []){		return true;	} else {		return false;	}}WAKLIB.utils.random = function(high, low){	low = typeof a !== 'undefined' ? low : 0;	return Math.floor(Math.random() * (high - low + 1)) + low;}WAKLIB.utils.indexOf = function(property, value, array){ //internal utility function for finding an object attribute in an array	var index = null;	for (var i = 0; i < array.length; i++) {	  if (array[i][property] === value) {	    index = i;	    break;	  }	}	return index;}WAKLIB.utils.generateFullName = function(firstName, lastName, partnerFirst, partnerLast){	var nameTotal = 0; //The unique value based on populated full name elements	//firstName = 1, lastName = 2, partnerfirst = 4, partnerLast = 8	nameTotal = (firstName == "" || firstName == null) ? nameTotal : nameTotal + 1;	nameTotal = (lastName == "" || lastName == null) ? nameTotal : nameTotal + 2;	nameTotal = (partnerFirst == "" || partnerFirst == null) ? nameTotal : nameTotal + 4;	nameTotal = (partnerLast == "" || partnerLast == null) ? nameTotal : nameTotal + 8;		switch (nameTotal) {		//Go through each name scenerio in order of likelyhood		case 0: //Nothing filled in			return "No Name";			break;		case 1: //First name filled in			return firstName; //Bob			break;		case 3: //First name & last name			return firstName + " " + lastName; //Bob Wilson			break;		case 15: //All values filled in			if(lastName == partnerLast){				return firstName + " & " + partnerFirst + " " + lastName; //Bob & Martha Wilson			} else {				return firstName + " " + lastName + " & " + partnerFirst + " " + partnerLast; //Bob Wilson & Martha Stevenson			}			break;		case 5: //Both first names			return firstName + " " + partnerFirst; //Bob & Martha			break;		case 7: //First, last and partner first			return firstName + " " + lastName + " & " + partnerFirst; //Bob Wilson & Martha			break;		case 13: //FirstName, partnerFirst, partnerLast			return firstName + "( " + partnerFirst + " " + partnerLast + " )"; //Bob (& Martha Wilson)			break;		case 12: //partnerFirst, partnerLast			return partnerFirst + " " + partnerLast; //Martha Wilson			break;		default: //all other scenarios			return "";	}}//*** WAK.events - a client side event systemWAKLIB.events = {};WAKLIB.events.events = []; //[{eventName, eventFunction()}]WAKLIB.events.listeners = []; //[{domID, eventName, functionName, listenerData}]//TODO: have it automatically populate an error divWAKLIB.events.addListener = function(domID, eventName, functionName, listenerData){	WAKLIB.events.listeners.push({eventName: eventName, domID: domID, functionName: functionName, listenerData: listenerData});	return WAKLIB.events.listeners.length;}WAKLIB.events.removeListener = function(domID, eventName){	var resultArray = WAKLIB.events.listeners;	if(eventName == undefined || eventName == null || eventName == ""){		for(i = WAKLIB.events.listeners.length - 1; i >= 0; i--){			if(WAKLIB.events.listeners[i].domID == domID){				WAKLIB.events.listeners.splice(i, 1);			}		}	} else if (domID == undefined || domID == null || domID == ""){		for(i = WAKLIB.events.listeners.length - 1; i >= 0; i--){			if(WAKLIB.events.listeners[i].eventName == eventName){				WAKLIB.events.listeners.splice(i, 1);			}		}	} else {		for(i = WAKLIB.events.listeners.length -1; i >= 0; i--){			if(WAKLIB.events.listeners[i].domID == domID && WAKLIB.events.listeners[i].eventName == eventName){				WAKLIB.events.listeners.splice(i, 1);			}		}	}	return true;};WAKLIB.events.removeEvent = function(eventName){	var eventIndex = WAKLIB.utils.indexOf('eventName', eventName, WAKLIB.events.events);	WAKLIB.events.events.splice(eventIndex, 1); //remove from event array	WAKLIB.events.removeListener(null, eventName); //remove all listeners	return true;};WAKLIB.events.dispatchEvent = function(eventName, dispatchData) {	var eventData = {};	var widgetList = [];	//find the event, call the event function, call listener functions	var eventIndex = WAKLIB.utils.indexOf('eventName', eventName, WAKLIB.events.events); //find if there is a declared event	var theEvent = WAKLIB.events.events[eventIndex];	if(eventIndex != null){		//there is a declared event, so call the event function		theEvent.eventFunction(theEvent, dispatchData); //call the event function before listener function		eventData = theEvent.eventData;	} else {		eventData = {}; //no event data as it's not declared.	}		matches = WAKLIB.events.listeners.filter(function(element){		if(element.eventName == eventName){			return element; //Add to the list of events that match		}	});	if(matches.length > 0){ //Fire the event function once		matches.forEach(function(element, index, array){			$$(element.domID)[element.functionName](dispatchData, element.listenerData, eventData); //call the listener function			widgetList.push($$(element.domID));		});	}	return widgetList;};WAKLIB.events.declareEvent = function(eventName, eventData, eventFunction){	var eventIndex = WAKLIB.utils.indexOf('eventName', eventName, WAKLIB.events.events);	if(eventIndex == null){		WAKLIB.events.events.push({eventName: eventName, eventData: eventData, eventFunction: eventFunction});		return WAKLIB.events.events[WAKLIB.events.events.length - 1];	}}//WAKLIB.validateWAKLIB.validate = {};WAKLIB.val = WAKLIB.validate; //short formWAKLIB.validate.settings = { //provides settings for flagging an offending widget	borderColor: '',	borderWidth: '',	backgroundColor: '',	fontWeight: ''	//could add shadow}WAKLIB.validate.flagWidgets = function(incoming, options){ //flags an offending widgets based on input, can also take a list of random widgets for styling only	var results = [];	var origStyle = '';	var cssObj = {};	var isWidget; //is a widget sent directly to funciton for styling, no validation data attached	var theWidget;	var isFlagged;	var widgetArray = WAKLIB.validate.makeArray(incoming)//in case there is only one item... wrap it.	widgetArray.forEach(function(element){ //for each result from a validation OR just plain widgets to style		isFlagged = false;		isWidget = WAKLIB.validate.isWidget(element); //		if(isWidget){			isFlagged = true;			theWidget = element;		} else {			if(element.result == false){				isFlagged = true			}			theWidget = element.widget		}		if(isFlagged){ //if the widget element failed validation			if(WAKLIB.utils.isEmpty(WAKLIB.validate.settings.errorClass)){				if(WAKLIB.validate.settings.borderColor != ''){					cssObj['border-top-color'] =  WAKLIB.validate.settings.borderColor;					cssObj['border-bottom-color'] = WAKLIB.validate.settings.borderColor;					cssObj['border-left-color'] = WAKLIB.validate.settings.borderColor;					cssObj['border-right-color'] = WAKLIB.validate.settings.borderColor;				}				if(WAKLIB.validate.settings.borderWidth != ''){					cssObj['border-top-width'] = WAKLIB.validate.settings.borderWidth;					cssObj['border-bottom-width'] = WAKLIB.validate.settings.borderWidth;					cssObj['border-left-width'] = WAKLIB.validate.settings.borderWidth;					cssObj['border-right-width'] = WAKLIB.validate.settings.borderWidth;				}				if(WAKLIB.validate.settings.backgroundColor != ''){					cssObj['background-color'] = WAKLIB.validate.settings.backgroundColor				}				if(WAKLIB.validate.settings.fontWeight != ''){					cssObj['font-weight'] = WAKLIB.validate.settings.fontWeight				}				origStyle = $('#' + theWidget.id).attr('style');						if(element.applyStyling != false){				 	theWidget.$domNode.css(cssObj);				}			} else { //style with a CSS class				if(element.applyStylign != false){					theWidget.addClass(WAKLIB.validate.settings.errorClass);				}			}			results.push({widget: theWidget, style: origStyle});		}	});	if(results.length == 1){		return results[0];	} else {		return results;	}}WAKLIB.validate.revertStyles = function(results){ //replaces existing inline styles with values captured during validation.	var isWidget = false;	var widgetID = '';	var widgetArray = WAKLIB.validate.makeArray(results)//in case there is only one item... wrap it.	results.reverse();	results.forEach(function(element){		isWidget = WAKLIB.validate.isWidget(element);		(isWidget)? widgetID = element.id : widgetID = element.widget.id;		if(element.style == undefined){			$('#' + widgetID).removeAttr('style');		} else {			$('#' + widgetID).attr('style', element.style);		}	});}WAKLIB.validate.makeArray = function(param){ //validates and prepares parameters	if(!(Object.prototype.toString.call( param ) === '[object Array]')){		var groupResult = param.result;		param = [param];		param[0].groupResult = groupResult;	}	return param;}WAKLIB.validate.isWidget = function(param){	var result = false;	try {		param.$domNode.hasClass('waf-widget')		result = true;	} catch(err) {		result = false;	}	return result;}WAKLIB.validate.hasValue = function(widgets, options, error){	var results = [];	var groupResult = true;	var groupMessage = '';	var isWidget = false;	var value = '';	try{options.applyStyling}catch(err){options = {}; options.applyStyling = true;}; // in case applyStyling was left out	var widgetArray = WAKLIB.validate.makeArray(widgets);	widgetArray.forEach(function (element){		isWidget = WAKLIB.validate.isWidget(element);		if(isWidget){			var cssStyle = $('#' + element.divID).attr('style');			value = element.getValue();		} else {			value = element;		}		if(value == null || value == undefined || value == '' || value == 0){			groupResult = false;			groupMessage = 'Value is empty'			results.push({widget: element, result: false, code: 'empty', message: 'Value is empty', style: cssStyle, applyStyling: options.applyStyling});		} else {			results.push({widget: element, result: true, code: '', message: '', style: cssStyle});		}	});	WAKLIB.validate.flagWidgets(results);	if(results.length == 1){		return results[0];	} else {		results[0].groupResult = groupResult;		results[0].groupMessage = groupMessage;		return results;	}		}WAKLIB.validate.length = function(widgets, options, error){	//Example: WAKLIB.VAL.length($$('widgetid'), $$('errorDivID'), {minLength: 6, maxLength: 20});	var isWidget = false;	var results = [];	var groupResult = true;	var groupMessage = '';	var elementMessage = '';	var value = '';	var elementResult = {};	var cssStyle = '';	try{options.applyStyling}catch(err){options = {}; options.applyStyling = true;}; // in case applyStyling was left out	var widgetArray = WAKLIB.validate.makeArray(widgets);	widgetArray.forEach(function(element){		elementResult = {};		isWidget = WAKLIB.validate.isWidget(element);		if(isWidget){			cssStyle = $('#' + element.divID).attr('style');			value = String(element.getValue());		} else {			value = String(element);		}		if(value.length < options.minLength){			elementMessage = 'Too short(min ' + options.minLength + ' characters)';			elementResult = {widget: element, result: false, code: 'short', message: elementMessage, style: cssStyle, applyStyling: options.applyStyling};			groupMessage = elementMessage;			groupResult = false;		}		if(value.length > options.maxLength){			elementMessage = 'Limit exceeded(' + options.maxLength + ' characters)';			elementResult = {widget: element, result: false, code: 'long', message: groupMessage, style: cssStyle, applyStyling: options.applyStyling};			groupMessage = elementMessage;			groupResult = false;		}		if(elementResult.result != false){ //it passed			elementResult = {widget: element, result: true, code: '', message: '', style: cssStyle, applyStyling: options.applyStyling};		}		results.push(elementResult);	});	WAKLIB.validate.flagWidgets(results);	if(results.length == 1){		return results[0];	} else {		results[0].groupResult = groupResult;		results[0].groupMessage = groupMessage;		return results;	}}WAKLIB.validate.isNumber = function(widgets, options, error){	}WAKLIB.validate.isEmail = function(widgets, options, error){	}WAKLIB.validate.equal = function(widgets, options, error){	//gets in values like ([value, value, value], {compareTo: value, strict: true, ignoreCase: true})	var results = [];	var groupResult = true;	var groupMessage = '';	var isWidget = false;	var compareToWidget = false;	var value = '';	try{options.applyStyling}catch(err){options = {}; options.applyStyling = true;}; // in case applyStyling was left out	var widgetArray = WAKLIB.validate.makeArray(widgets);	widgetArray.forEach(function (element){		isWidget = WAKLIB.validate.isWidget(element);		if(isWidget){			var cssStyle = $('#' + element.divID).attr('style');			value = element.getValue();		} else {			value = element;		}		compareToWidget = WAKLIB.validate.isWidget(options.compareTo);		if(compareToWidget == true){			options.compareTo = options.compareTo.getValue();		}		if(options.ignoreCase == true){			options.compareTo = options.compareTo.toLowerCase();			value = value.toLowerCase();		}		if(options.strict == true){			if(value === options.compareTo){				results.push({widget: element, result: true, code: '', message: '', style: cssStyle, applyStyling: options.applyStyling});			} else {				groupMessage = 'Values are not equal';				groupResult = false;				results.push({widget: element, result: false, code: 'notEqual', message: groupMessage, style: cssStyle, applyStyling: options.applyStyling});			}			} else {			if(value == options.compareTo){				results.push({widget: element, result: true, code: '', message: '', style: cssStyle, applyStyling: options.applyStyling});			} else {				groupMessage = 'Values are not equal';							groupResult = false;				results.push({widget: element, result: false, code: '', message: groupMessage, style: cssStyle, applyStyling: options.applyStyling});			}			}			});	WAKLIB.validate.flagWidgets(results);	if(results.length == 1){		return results[0];	} else {		results[0].groupResult = groupResult;		results[0].groupMessage = groupMessage;		return results;	}}WAKLIB.validate.unique = function(widgets, options, error){	//Options sends in the datastore class name as options.datastoreClass	var results = [];	var groupResult = true;	var groupMessage = '';	var isWidget = false;	var value = '';}WAKLIB.validate.multi = function(validations, options, error){	//get objects like [{widgets: widgetRef, valMethod: 'isEmail', options: {option: 'optionString'}, errorDiv: errorObj},{},{}]	//Goes through each array element and validates the form according to rules.	var results = [];	var multiResult = true; //the validation of the entire multi request	var multiMessage = '';	var validationArray = WAKLIB.validate.makeArray(validations);	validationArray.forEach(function(element){		switch(element.method){			case 'hasValue':				stepResults = WAKLIB.validate.hasValue(element.widgets, element.options, element.error);				break;			case 'length':				stepResults = WAKLIB.validate.length(element.widgets, element.options, element.error);				break;			case 'equal':				stepResults = WAKLIB.validate.equal(element.widgets, element.options, element.error);				break;			default:				stepResults = [];		}		stepResults = WAKLIB.validate.makeArray(stepResults);				if(!stepResults[0].groupResult){			multiResult = false;			multiMessage = stepResults[0].groupMessage;		}		stepResults = WAKLIB.validate.makeArray(stepResults);		results = results.concat(stepResults);		stepResults = [];	});	results[0].multiResult = multiResult;	results[0].multiMessage = multiMessage	return results;}WAKLIB.style = {};WAKLIB.style.replaceCSS = function(widgets, css){//fully replaces the inline CSS on a widget(s)var widgetArray = WAKLIB.validate.makeArray(widgets);	widgetArray.forEach(function (element){		$('#' + element.id).attr('style', css);	});}WAKLIB.style.appendCSS = function(widgets, css){//adds CSS to the existing inline CSS of a widget(s)var widgetArray = WAKLIB.validate.makeArray(widgets);widgetArray.forEach(function (element){		var existing = $('#' + element.id).attr('style');		if(existing != undefined){			css = existing + " " + css;		}		$('#' + element.id).attr('style', css);	});}